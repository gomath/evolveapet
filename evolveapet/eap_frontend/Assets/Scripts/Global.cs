//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18052
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using UnityEngine;

namespace EvolveAPet
{
	public class Global
	{
		// Use this random to generate all random numbers in the whole program. C# random sucks otherwise if created in multiple classes.
		public static System.Random rand = new System.Random();

		public static int EYES_LOWER_BOUND = 1; // inclusive
		public static int EYES_UPPER_BOUND = 4; // exclusive

		public static int ARMS_LOWER_BOUND = 0; // inclusive
		public static int ARMS_UPPER_BOUND = 2; // exclusive

		public static int NUM_OF_CHROMOSOMES = 7;
		public static string[] prefixes = new string[] 
		{"Sir ", "Captain ", "Quacker ", "The Honorable ", "Blue ", "Bob", "Centi", "Flying ", "Electric ", "Leafy ", "Frilled ", "Guppy "};//12
		public static string[] names = new string[]
		{"Boof", "Tom", "Emilian", "Matej", "Marianne", "Rudolph", "Nick", "Mary", "Pika", "Stuart", "Mox", "Maximillian", "Steve"};
		public static string[] suffixes = new string[] 
		{"asaurus", "ician", " Senior", " Junior", " II", " III", " IV", " V", "-nyan", "eleon", "fish", "chu"};//12
		public readonly static String mapName = "one_to_one_mapping.map";
		public static Dictionary<Locus,Locus> mapFtB; // map front-end to backend
		public static Dictionary<Locus,Locus> mapBtF; // map back-end to frontend

		/// <summary>
		/// Loads scrambling map from hard disk.
		/// Creates corresponding mapFtB and mapBtF 
		/// </summary>
		public static void LoadMap(){
			BinaryFormatter bf = new BinaryFormatter ();

			FileStream inStream = new FileStream (mapName, FileMode.Open);
			mapFtB = bf.Deserialize(inStream) as Dictionary<Locus,Locus>;

			// Creating inverse map
			mapBtF = new Dictionary<Locus,Locus> (new LocusEqualityComparer());
			Dictionary<Locus,Locus>.KeyCollection keys = mapFtB.Keys;
			foreach(Locus key in keys){
				Locus value = mapFtB[key];
				mapBtF.Add(value,key);
			}

			/*
			Debug.Log(mapFtB.ContainsKey (new Locus (0, 0)));
			Debug.Log(mapFtB.ContainsKey (new Locus (0, 10)));

			Debug.Log(mapBtF.ContainsKey (new Locus (0, 0)));

			Debug.Log(mapBtF.ContainsKey (new Locus (0, 10)));
			*/
			Locus l = mapFtB [new Locus (0, 0)];
			//Debug.Log (l.Chromosome);
		}

		// TODO - untested
		/// <summary>
		/// Given front-end chromosomes, returns the corresponding backend chromosomes by shifting appropriate genes to appropriates Loci.
		/// </summary>
		/// <returns>The end to backend chromosomes.</returns>
		/// <param name="frontEndChromosomes">Front end chromosomes.</param>
		public static Chromosome[] FrontEndToBackendChromosomes(Chromosome[] frontEndChromosomes){
			if (mapFtB == null) {
				LoadMap ();
			}

			Chromosome[] backEndChromosomes = new Chromosome[NUM_OF_CHROMOSOMES];
			for (int i=0; i<Global.NUM_OF_CHROMOSOMES; i++) {
				Gene[] temp = new Gene[MyDictionary.numOfGenesOnChromosome[(EnumBodyPart)i]];
				for(int j=0; j<MyDictionary.numOfGenesOnChromosome[(EnumBodyPart)i]; j++){
					Locus frontEndLocus = mapBtF[new Locus(i,j)];
					int ch = frontEndLocus.Chromosome;
					int g = frontEndLocus.GeneNumber;
					temp[j] = frontEndChromosomes[ch].Genes[g];
				}
				backEndChromosomes[i] = new Chromosome(temp,i);	                    
			}
			return backEndChromosomes;
			
		}

	}
}

